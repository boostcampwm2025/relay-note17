1. 미션을 보고 체크리스트 항목을 좀 보완하기 위해 조언 듣기
  - 체크리스트 항목을 작성할 때, 보통 미션과 사전 지식을 확인하고 미션을 수행에 필요한 내용만 주로 작성을 하였는데, 실제로 체크리스트 점검 과정에서 보면 이 외에 체크해야 할 점이 많았다. AI를 활용해서 내가 작성한 체크리스트를 보완하고 미션 수행에 필요한 지식을 추가적으로 학습해보기 위해서 선택하였다.


## Day6
### 내가 작성한 체크리스트

- [ ] 객체지향 설계와 객체지향 프로그래밍 패러다임이란?
- [ ] 객체지향 설계 원칙에 대해 알아보자
- [ ] javscript의 클래스 문법 학습
- 미션 설계하기
  - [ ] 보드 설계
  - 캐릭터 class 설계
    - [ ] 위치, 스톤, 공격력, 체력
    - [ ] 특정 위치 이동
    - [ ] 공격
  - 각 캐릭터 들의 특징을 override한 각 클래스 설계
    - [ ] 타노스
    - [ ] 블랙위도우
    - [ ] 로키
    - [ ] 헐크
    - [ ] 스파이더맨
    - [ ] 토르
    - [ ] 닥터스트레인지
- [ ] 결과 출력
- [ ] 리팩토링

이렇게 작성한 체크리스트를 보완해달라고 gpt에게 요청하였더니

### AI가 보완해준 체크리스트

-  🧠 객체지향 개념 학습
- [ ] 객체지향 설계 vs 객체지향 프로그래밍의 차이 이해
- [ ] 객체란 무엇이며, 어떻게 설계하는가?
- [ ] OOP 설계 원칙(SRP, OCP 등) 학습 및 간단한 예시 코드 작성
- [ ] JS 클래스 문법 학습 (constructor, extends, super, static, private 등)

- 🗺️ 미션 설계
- [ ] Board 클래스: 맵의 상태 관리
- [ ] Character 클래스: 기본 이동/공격/스탯
- [ ] 각 캐릭터별 클래스(상속 + override)
  - [ ] 타노스: 예시) 무작위 스톤 제거 능력
  - [ ] 헐크: 예시) 공격 시 확률적 크리티컬
  - ...
- [ ] GameEngine: 게임의 턴 진행, 캐릭터 순서, 승패 판정

- 🧪 테스트 / 시나리오
- [ ] 캐릭터 이동/공격 시나리오 작성 및 검증
- [ ] 다형성 기반으로 동일 메서드로 서로 다른 결과 유도

-  🧹 리팩토링
- [ ] 중복 코드 제거
- [ ] 역할별 모듈 분리
- [ ] 클래스 책임 명확하게 분리

이렇게 알려주었고 필요한 부분을 추가로 작성할 수 있었다.

---

## day 7
### 내가 작성한 체크리스트

- [ ] 일반적인 운영체제 파일시스템의 역할과 I/O 프로그래밍에 대해 학습하기
- [ ] FAT12와 같은 단순한 파일 시스템의 구조 학습하기
- Software Test란?
  - [ ] 단위 테스트, 통합 테스트, 시스템 테스트, 인수 테스트에 대해 학습하고 정리하기
  - [ ] UI test, E2E test에 대해 알아보고 정리하기
  - [ ] Mocha와 Jest에 대해 학습하기
  - [ ] 테스트 코드의 작성 시점에 대해 생각하고 정리하기
  - [ ] 의미 있는 테스트의 기준에 대해 생각하고 정리하기
- 가상 파일 시스템 설계
  - [ ] 명령 입력용 CLI 구현하기
  - [ ] 파일 시스템 구조 설계하고 초기화 함수 작성하기
  - [ ] 디렉토리 생성 기능 구현
    - [ ] 단위테스트가 필요한지 고려하기
    - [ ] 단위테스트
  - [ ] 텍스트 파일 생성 기능 구현
    - [ ] 단위테스트가 필요한지 고려하기
    - [ ] 단위테스트
  - [ ] 디렉토리 읽기 기능 구현
    - [ ] 단위테스트가 필요한지 고려하기
    - [ ] 단위테스트
  - [ ] 텍스트 파일 읽기 기능 구현
    - [ ] 단위테스트가 필요한지 고려하기
    - [ ] 단위테스트
  - [ ] 영속성 보장 기능 구현

### AI가 작성한 체크리스트

- 운영체제와 파일 시스템 기초
- [ ] 일반적인 운영체제의 파일 시스템 역할 이해
  - 파일 생성/저장/탐색/삭제 처리 흐름
  - 파일 디스크립터, inode, 블록 등 핵심 개념
- [ ] I/O 프로그래밍 개요
  - 시스템 콜(`read`, `write`, `open`, `close`)과 버퍼링 이해
  - 블로킹 vs 논블로킹 I/O
- [ ] FAT12 등 단순한 파일 시스템 구조 학습
  - FAT 테이블, 클러스터, 루트 디렉토리 구조
  - 파티션 구조 및 부트 섹터 기본 개념

-  소프트웨어 테스트 학습
- [ ] 테스트 계층 구조 학습
  - 단위(Unit), 통합(Integration), 시스템(System), 인수(Acceptance) 테스트 개념
- [ ] UI 테스트, E2E(End-to-End) 테스트 학습
  - Cypress, Playwright 등 도구 개요
- [ ] 테스트 프레임워크 비교
  - Mocha: 유연한 테스트 러너
  - Jest: 통합된 테스트 도구 (모킹/스냅샷 등)
- [ ] 테스트 코드 작성 시점에 대한 고찰
  - TDD(Test-Driven Development) vs 테스트 사후 작성
- [ ] 의미 있는 테스트란?
  - 명세 기반, 경계 조건, 부정 테스트, 실패 예측 테스트 포함

- 가상 파일 시스템 설계 및 구현
> 실제 OS 파일 시스템을 모방한 자바스크립트 기반 미니 파일 시스템을 CLI로 구축한다.

- 초기 시스템 설계
- [ ] CLI(Command Line Interface) 구현
  - 사용자 명령을 해석하고 처리
  - 기본 명령어 파싱 구조 설계
- [ ] 파일 시스템 구조 설계 및 초기화
  - 디스크 크기, 클러스터 단위, 루트 디렉토리, FAT 영역 등 구조화
  - 초기화 함수 구현 (포맷)

- 디렉토리 및 파일 기능 구현
- 디렉토리 관련
- [ ] `mkdir <name>`: 디렉토리 생성
  - [ ] 디렉토리 중복 방지
  - [ ] 경로 지원 고려 (`mkdir a/b`)
  - [ ] 단위 테스트 설계 및 작성

- [ ] `ls <dir>`: 디렉토리 읽기
  - [ ] 하위 파일/폴더 목록 출력
  - [ ] 단위 테스트 설계 및 작성

- 텍스트 파일 관련
- [ ] `touch <filename>`: 텍스트 파일 생성
  - [ ] 중복 생성 방지
  - [ ] 초기 텍스트 입력 여부 결정
  - [ ] 단위 테스트 설계 및 작성

- [ ] `cat <filename>`: 텍스트 파일 읽기
  - [ ] 파일 존재 확인, 권한 체크 등 예외 처리
  - [ ] 단위 테스트 설계 및 작성

- 영속성 구현

- [ ] 프로그램 종료 후에도 파일 시스템 상태 유지
  - 로컬 저장소(LocalStorage, 파일 등)에 직렬화 저장
  - 재시작 시 복원 로직 구현

- 확장 학습 항목 (선택)
- [ ] 경로 기반 탐색 기능 (`cd`, 상대/절대 경로)
- [ ] 파일 삭제 기능 구현 (`rm`, `rmdir`)
- [ ] 텍스트 파일 수정 및 덮어쓰기 (`echo`, `write`)
- [ ] FAT 공간 관리 최적화 (재사용/클러스터 해제 등)
- [ ] 권한 모델 추가 (`chmod`, `read-only` 속성 등)
- [ ] 사용자 개념 및 로그인 시스템 도입

- 학습 목표 정리
- 운영체제의 파일 시스템 동작 원리를 코드로 체화
- CLI 환경에서 명령어 해석 및 파일 시스템 설계 능력 향상
- 테스트 주도 개발(TDD)의 실습과 테스트 대상 분리 능력 강화
- 간단한 파일 시스템의 영속성과 상태 보존 기술 이해

---

## day 8

### 내가 작성한 체크리스트

- 함수형 프로그래밍에 대해 알아보고 학습하기
  - [ ] 함수형 프로그래밍이란 무엇인가?
  - [ ] 순수 함수 이해하기
  - [ ] 불변성 학습
  - [ ] 참조 투명성 이해하기
  - [ ] 일급 객체로서의 함수 개념
  - [ ] 고차 함수 이해하기
  - [ ] 클로저의 개념과 함수형에서의 역할
- 연결리스트 함수형 프로그래밍으로 구현
  - [ ] append()
  - [ ] insert()
  - [ ] remove()
  - [ ] item()
  - [ ] clear()
- 해시맵 함수형 프로그래밍으로 구현
  - [ ] put()
  - [ ] remove()
  - [ ] get()
  - [ ] contains();
  - [ ] keys()
- 책 대여, 관리 프로그램
  - [ ] 설계
  - 도서 관리 기능
    - [ ] add()
    - [ ] rent()
    - [ ] return()
    - [ ] sortByDate()
    - [ ] top10rent()
    - [ ] findBy()
    - [ ] totalRent()
- [ ] js에서의 함수형 패턴
- [ ] Ramda.js, lodash/fp 등 함수형 라이브러리에 대해 알아보기
- [ ] 불변성 보장을 위한 구조 공유 기법 이해


### AI가 작성한 체크리스트

- 함수형 프로그래밍 기초 이해
- [ ] 함수형 프로그래밍이란 무엇인가?
  - 명령형 vs 선언형 프로그래밍 비교
  - 상태 변화와 부수효과 최소화
- [ ] 순수 함수(Pure Function) 이해하기
  - 동일한 입력에 항상 동일한 출력을 반환
  - 외부 상태를 참조하거나 변경하지 않음
- [ ] 불변성(Immutability) 학습
  - 원시 값과 참조 값의 불변 처리
  - 객체/배열 불변성 유지 방법
- [ ] 참조 투명성(Referential Transparency) 이해하기
  - 표현식이 값으로 대체되어도 프로그램 의미가 동일함
- [ ] 일급 객체로서의 함수
  - 함수는 변수에 할당, 인자로 전달, 반환 가능
- [ ] 고차 함수(Higher-Order Function) 이해하기
  - 함수를 인자로 받거나 함수를 반환하는 함수
- [ ] 클로저(Closure)와 함수형에서의 역할
  - 외부 함수의 변수에 접근 가능한 내부 함수
  - 상태 은닉과 부분 적용(partial application)에 활용

- 자료구조 함수형으로 구현하기

- 연결 리스트 (LinkedList)

- [ ] `append(value)` - 리스트 끝에 요소 추가
- [ ] `insert(index, value)` - 지정 위치에 요소 삽입
- [ ] `remove(index)` - 특정 위치 요소 제거
- [ ] `item(index)` - 특정 위치 요소 조회
- [ ] `clear()` - 리스트 초기화
- [ ] 고차 함수(map, filter, reduce)를 적용한 활용 예제 작성

- 해시맵 (HashMap)

- [ ] `put(key, value)` - 키에 값 저장
- [ ] `remove(key)` - 특정 키 제거
- [ ] `get(key)` - 특정 키에 해당하는 값 조회
- [ ] `contains(key)` - 키 존재 여부 확인
- [ ] `keys()` - 모든 키 반환
- [ ] 충돌 해결을 위한 체이닝(Chaining) 또는 오픈 어드레싱 방식 실습


- 실습 프로젝트: 책 대여 및 관리 프로그램

- 설계 및 모델링

- [ ] 도서(Book) 객체 설계: `title`, `author`, `year`, `publisher`, `isbn`, `volume`, `subjectCode` 등
- [ ] 사용자(User) 또는 대여 기록(RentalHistory) 모델 추가 고려
- [ ] 상태 변화를 줄이기 위한 불변 자료구조 기반 설계

- 기능 구현

- [ ] `add(book)` - 도서 추가
- [ ] `rent(isbn)` - 도서 대여
- [ ] `return(isbn)` - 도서 반납
- [ ] `sortByDate()` - 출판일 기준 정렬
- [ ] `top10rent()` - 대여 횟수 상위 10권 조회
- [ ] `findBy(field, value)` - 조건 기반 검색
- [ ] `totalRent()` - 전체 대여 횟수 조회

- 자바스크립트에서 함수형 패턴 적용

- [ ] `Array.prototype.map`, `filter`, `reduce` 심화 학습
- [ ] 함수 조합(function composition)과 파이프(pipe) 패턴 익히기
- [ ] 커링(currying)과 partial application 실습
- [ ] 모나드(monad), functor 등 고급 개념 기본 이해

- 함수형 프로그래밍 라이브러리 탐색

- [ ] Ramda.js 기초 문법 및 사용법
- [ ] lodash/fp 모듈과 일반 lodash 차이점
- [ ] `compose`, `pipe`, `curry`, `cloneDeep`, `assocPath` 등의 함수 실습
- [ ] 불변성 보장을 위한 구조 공유(Structural Sharing) 기법 이해
  - Persistent Data Structure 개념
  - Immer.js와 비교 학습 (선택)

---

## day9
### 내가 작성한 체크리스트

- [ ] 프로세스와 스레드의 차이 이해
- [ ] 레이스 컨디션이 발생하는 원리 학습
- [ ] 운영체제의 스케쥴링 학습
- [ ] 동기와 비동기 작업 처리 방식에 대해 비교하고 학습
- 스레드 레이스
  - [ ] 멀티 스레드를 생성하는 방식 학습
  - [ ] 운영체제와 언어 플랫폼에서 제공하는 멀티 스레드 API 학습
  - [ ] 프로그램 설계
  - [ ] 구현
- 비동기 이벤트 매니저
  - [ ] Publisher-Subscrber 패턴을 사용하는 경우와 어떤 구현 방식이 있는지 학습
  - [ ] EventEmiiter 라이브러리 학습
  - [ ] 싱글톤 패턴 학습
  - [ ] 프로그램 설계
  - [ ] sharedInstance() 구현
  - [ ] add(subscriber, eventName, sender, handler) 구현
  - [ ] remove(subscriber) 구현
  - [ ] postEvent(eventName, sender, userData) 구현
  - [ ] description() 구현



### AI가 작성한 체크리스트

- 🏗️ 기초 개념 이해

- [ ] **프로세스와 스레드의 차이 이해**
  - 메모리 구조(텍스트, 힙, 스택, 데이터 영역) 관점에서 비교
  - 컨텍스트 스위칭의 비용과 영향
- [ ] **운영체제의 스케쥴링 방식 이해**
  - Preemptive vs Non-preemptive
  - Thread 우선순위와 starvation
- [ ] **동기 vs 비동기 처리 비교 및 이해**
  - Blocking / Non-blocking
  - Promise, Callback, async/await의 작동 원리


- ⚠️ 레이스 컨디션의 본질

- [ ] **레이스 컨디션이 발생하는 원리 학습**
  - 공유 자원, 임계 구역(Critical Section) 개념
  - 원자성(Atomicity)과 context switching 간섭 이해
- [ ] **대표적인 Race Condition 사례 분석**
  - 증가 연산(`counter++`) 예제
  - 파일 쓰기/읽기 중 발생하는 충돌


- 🔀 멀티스레드 프로그래밍과 레이스 컨디션

- 🌐 멀티스레드 기초

- [ ] **멀티스레드 생성 방식 학습**
  - 언어별 예시 (C++11 std::thread, Java Thread, Node.js Worker Thread)
- [ ] **운영체제 & 언어 플랫폼의 스레드 API 학습**
  - pthreads, Java concurrency, Node.js Worker API
- [ ] **공유 자원 보호 기법 학습**
  - [ ] Mutex, Spinlock, Semaphore
  - [ ] Atomic 변수, Volatile, Memory Barrier
  - [ ] Lock-free 프로그래밍 소개

- 🧠 스레드 기반 Race Condition 학습 실습

- [ ] **멀티스레드 프로그램 설계**
- [ ] **레이스 컨디션 발생 코드 구현**
- [ ] **뮤텍스 등으로 해결한 버전 구현**
- [ ] **테스트 및 디버깅 방법 학습**
  - Thread sanitizer, 디버깅 툴 활용


- ⏳ 비동기 환경과 Race Condition

- 📬 비동기 이벤트 매니저 학습

- [ ] **Publisher-Subscriber 패턴 이해**
  - Observer 패턴과 비교
  - 동기/비동기 흐름에서의 적용 차이
- [ ] **EventEmitter 라이브러리 학습 (Node.js 기준)**
  - on, emit, once, removeListener 등 API 학습

- 🧱 설계 및 구현 실습

- [ ] **싱글톤 패턴 학습**
  - Thread-safe 싱글톤 구현 (lazy init)
- [ ] **비동기 이벤트 매니저 설계**
- [ ] **sharedInstance() 구현**
- [ ] **add(subscriber, eventName, sender, handler) 구현**
- [ ] **remove(subscriber) 구현**
- [ ] **postEvent(eventName, sender, userData) 구현**
- [ ] **description() 구현 (디버깅용)**

- 🧪 실전 대비

- [ ] **동시성 디버깅 및 테스트 방법 학습**
  - Race condition 탐지 툴 (Helgrind, TSAN 등)
- [ ] **Deadlock, Livelock, Starvation 등 유사 문제 구분 학습**
- [ ] **실제 시스템에서의 사례 조사**
  - MySQL, Node.js, Android 등에서의 레이스 컨디션 사례
