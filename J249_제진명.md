1. 미션을 보고 체크리스트 항목을 좀 보완하기 위해 조언 듣기
  - 체크리스트 항목을 작성할 때, 보통 미션과 사전 지식을 확인하고 미션을 수행에 필요한 내용만 주로 작성을 하였는데, 실제로 체크리스트 점검 과정에서 보면 이 외에 체크해야 할 점이 많았다. AI를 활용해서 내가 작성한 체크리스트를 보완하고 미션 수행에 필요한 지식을 추가적으로 학습해보기 위해서 선택하였다.


### 7.21 월요일
# Day6 나만의 체크포인트

- [ ] 객체지향 설계와 객체지향 프로그래밍 패러다임이란?
- [ ] 객체지향 설계 원칙에 대해 알아보자
- [ ] javscript의 클래스 문법 학습
- 미션 설계하기
  - [ ] 보드 설계
  - 캐릭터 class 설계
    - [ ] 위치, 스톤, 공격력, 체력
    - [ ] 특정 위치 이동
    - [ ] 공격
  - 각 캐릭터 들의 특징을 override한 각 클래스 설계
    - [ ] 타노스
    - [ ] 블랙위도우
    - [ ] 로키
    - [ ] 헐크
    - [ ] 스파이더맨
    - [ ] 토르
    - [ ] 닥터스트레인지
- [ ] 결과 출력
- [ ] 리팩토링

이렇게 작성한 체크리스트를 보완해달라고 gpt에게 요청하였더니

# Day6 나만의 체크포인트 (보완판)

## 🧠 객체지향 개념 학습
- [ ] 객체지향 설계 vs 객체지향 프로그래밍의 차이 이해
- [ ] 객체란 무엇이며, 어떻게 설계하는가?
- [ ] OOP 설계 원칙(SRP, OCP 등) 학습 및 간단한 예시 코드 작성
- [ ] JS 클래스 문법 학습 (constructor, extends, super, static, private 등)

## 🗺️ 미션 설계
- [ ] Board 클래스: 맵의 상태 관리
- [ ] Character 클래스: 기본 이동/공격/스탯
- [ ] 각 캐릭터별 클래스(상속 + override)
  - [ ] 타노스: 예시) 무작위 스톤 제거 능력
  - [ ] 헐크: 예시) 공격 시 확률적 크리티컬
  - ...
- [ ] GameEngine: 게임의 턴 진행, 캐릭터 순서, 승패 판정

## 🧪 테스트 / 시나리오
- [ ] 캐릭터 이동/공격 시나리오 작성 및 검증
- [ ] 다형성 기반으로 동일 메서드로 서로 다른 결과 유도

## 🧹 리팩토링
- [ ] 중복 코드 제거
- [ ] 역할별 모듈 분리
- [ ] 클래스 책임 명확하게 분리

이렇게 알려주었고 필요한 부분을 추가로 작성할 수 있었다.


day 9 

- [ ] 프로세스와 스레드의 차이 이해
- [ ] 레이스 컨디션이 발생하는 원리 학습
- [ ] 운영체제의 스케쥴링 학습
- [ ] 동기와 비동기 작업 처리 방식에 대해 비교하고 학습
- 스레드 레이스
  - [ ] 멀티 스레드를 생성하는 방식 학습
  - [ ] 운영체제와 언어 플랫폼에서 제공하는 멀티 스레드 API 학습
  - [ ] 프로그램 설계
  - [ ] 구현
- 비동기 이벤트 매니저
  - [ ] Publisher-Subscrber 패턴을 사용하는 경우와 어떤 구현 방식이 있는지 학습
  - [ ] EventEmiiter 라이브러리 학습
  - [ ] 싱글톤 패턴 학습
  - [ ] 프로그램 설계
  - [ ] sharedInstance() 구현
  - [ ] add(subscriber, eventName, sender, handler) 구현
  - [ ] remove(subscriber) 구현
  - [ ] postEvent(eventName, sender, userData) 구현
  - [ ] description() 구현



# 🧠 Race Condition 학습 To-Do List

## 🏗️ 기초 개념 이해

- [ ] **프로세스와 스레드의 차이 이해**
  - 메모리 구조(텍스트, 힙, 스택, 데이터 영역) 관점에서 비교
  - 컨텍스트 스위칭의 비용과 영향
- [ ] **운영체제의 스케쥴링 방식 이해**
  - Preemptive vs Non-preemptive
  - Thread 우선순위와 starvation
- [ ] **동기 vs 비동기 처리 비교 및 이해**
  - Blocking / Non-blocking
  - Promise, Callback, async/await의 작동 원리

---

## ⚠️ 레이스 컨디션의 본질

- [ ] **레이스 컨디션이 발생하는 원리 학습**
  - 공유 자원, 임계 구역(Critical Section) 개념
  - 원자성(Atomicity)과 context switching 간섭 이해
- [ ] **대표적인 Race Condition 사례 분석**
  - 증가 연산(`counter++`) 예제
  - 파일 쓰기/읽기 중 발생하는 충돌

---

## 🔀 멀티스레드 프로그래밍과 레이스 컨디션

### 🌐 멀티스레드 기초

- [ ] **멀티스레드 생성 방식 학습**
  - 언어별 예시 (C++11 std::thread, Java Thread, Node.js Worker Thread)
- [ ] **운영체제 & 언어 플랫폼의 스레드 API 학습**
  - pthreads, Java concurrency, Node.js Worker API
- [ ] **공유 자원 보호 기법 학습**
  - [ ] Mutex, Spinlock, Semaphore
  - [ ] Atomic 변수, Volatile, Memory Barrier
  - [ ] Lock-free 프로그래밍 소개

### 🧠 스레드 기반 Race Condition 학습 실습

- [ ] **멀티스레드 프로그램 설계**
- [ ] **레이스 컨디션 발생 코드 구현**
- [ ] **뮤텍스 등으로 해결한 버전 구현**
- [ ] **테스트 및 디버깅 방법 학습**
  - Thread sanitizer, 디버깅 툴 활용

---

## ⏳ 비동기 환경과 Race Condition

### 📬 비동기 이벤트 매니저 학습

- [ ] **Publisher-Subscriber 패턴 이해**
  - Observer 패턴과 비교
  - 동기/비동기 흐름에서의 적용 차이
- [ ] **EventEmitter 라이브러리 학습 (Node.js 기준)**
  - on, emit, once, removeListener 등 API 학습

### 🧱 설계 및 구현 실습

- [ ] **싱글톤 패턴 학습**
  - Thread-safe 싱글톤 구현 (lazy init)
- [ ] **비동기 이벤트 매니저 설계**
- [ ] **sharedInstance() 구현**
- [ ] **add(subscriber, eventName, sender, handler) 구현**
- [ ] **remove(subscriber) 구현**
- [ ] **postEvent(eventName, sender, userData) 구현**
- [ ] **description() 구현 (디버깅용)**

---

## 🧪 실전 대비

- [ ] **동시성 디버깅 및 테스트 방법 학습**
  - Race condition 탐지 툴 (Helgrind, TSAN 등)
- [ ] **Deadlock, Livelock, Starvation 등 유사 문제 구분 학습**
- [ ] **실제 시스템에서의 사례 조사**
  - MySQL, Node.js, Android 등에서의 레이스 컨디션 사례
